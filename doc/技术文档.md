### 教程

[如何写一个malloc](https://github.com/danluu/malloc-tutorial)



### 第一题：简单的内存分配器

- 实现一个内存分配器（allocator），并具备基本的功能;

- 支持的接口至少包括malloc、calloc、realloc、free;

- 具体实现可参考glibc/Ptmalloc2、[_mimalloc_](https://github.com/microsoft/mimalloc) 、[_tcmalloc_](https://github.com/gperftools/gperftools)、[_jemalloc_](https://github.com/jemalloc/jemalloc)。

  

        最佳适应算法 		

     用多个双向循环链表达到O(1)的时间复杂度
    
     ```
     malloc		直接进行内存分配
     calloc 		对分配的内存进行初始化
     realloc		对已经分配的内存进行重新分配，先free再分配
     			如果需要分配内存小于原来的内存，直接切割
     			如果分配内存等于直接返回
     			如果分配内存大于已经分配的内存，检查后面是否有足够空间，不够free再分配
     free		对已经分配的内存进行释放
     ```
    
     - 对于大内存的分配可以使用位运算画一个图来进行加速[LiteOS内存管理：TLSF算法](https://www.jianshu.com/p/01743e834432)
    
          超大的内存分配直接使用位图先查找
    
          Unsigned long long (C99)	  8个字节，一共64位足够使用了
    
          或者
          
          

数据结构

### 第二题：支持多线程的高效内存分配器

- 在第一题的基础上，支持多线程和并发 （利用锁机制保护相关操作的临界区）;

- 通过benchmark测试，benchmark的参考实现为[_mimalloc-bench_](https://github.com/daanx/mimalloc-bench);

- 根据benchmark测试的性能数据，以及测试中占用的物理内存，综合评估方案，目标平台x86_64。

     多线程

     对于多线程考虑用无锁的方法，对每个进程考虑使用不同的内存池，而不是一直等待一个加锁区域，但是内存池的数量要被限制在一个数量，而不是无止尽地增加

     因此在设计第一题的时候需要先将第二题先设计好，并且利用宏给出不同的编译版本

     ```
     当一个线程需要使用malloc分配内存的时候，会先查看该线程的私有变量中是否已经存在一个分配区。若是存在。会尝试对其进行加锁操作。若是加锁成功，就在使用该分配区分配内存，若是失败，就会遍历循环链表中获取一个未加锁的分配区。若是整个链表中都没有未加锁的分配区，则malloc会开辟一个新的分配区，将其加入全局的循环链表并加锁，然后使用该分配区进行内存分配。当释放这块内存时，同样会先获取待释放内存块所在的分配区的锁。若是有其他线程正在使用该分配区，则必须等待其他线程释放该分配区互斥锁之后才能进行释放内存的操作。
     ```

     

### 第三题：支持内存池的内存分配器

- 内存池是一个块预分配的内存区域，基于内存池的内存分配和释放都在内存池中完成;

- 支持基于处理器核心亲和度的内存池管理（以提高访存性能）;

- 支持的接口至少包括pool_create、pool_clear、pool_destroy、palloc、pcalloc;

- 参考实现为[_apr_pool_](https://github.com/apache/apr)，以及Linux的NUMA机制。

     实现定长的内存池，

     了解apr_poor的实现，NUMA机制的实现

```
这是一组与内存池有关的函数，通常用于管理固定大小的内存块以提高内存分配效率。下面对这些函数进行简要介绍：

pool_create：用于创建一个内存池，并指定内存池中每个内存块的大小和数量。

pool_clear：用于将内存池中的所有内存块重置为未使用状态。

pool_destroy：用于销毁一个内存池，并释放所有相关内存。

palloc：用于从内存池中分配一个指定大小的内存块。

pcalloc：与 palloc 类似，但它会将分配的内存块初始化为零。

通过使用内存池，可以避免频繁的内存分配和释放操作，从而提高内存管理的效率。同时，为不同线程分配独立的内存池可以避免线程之间的竞争和冲突，提高系统的响应速度。
```



### 第四题：高可靠的内存管理器

- 在第一题的基础上，实现一个高可靠的内存管理器;

- 可以采用校验、备份、三模冗余、纠删码等各种方式，实现抗单粒子翻转的功能;

- 已分配内存的1个bit值出现错误的情况，依然能够读取正确的值;

- 对有异常的内存，能够自动修复;

- 上述处理层的加入，内存无法直接读取，需要内存的读写接口，实现内存在读写中数据的自动冗余备份、校验和纠错写;

- 本题测试方法：程序运行过程中，外部检测框架修改特定内存来模拟异常，程序内存不会出现读写错误。

     

     

     重新设计一套malloc接口加上后缀

     实现采用不定长内存池，一次性分配三倍内存保证三模检查

     这个位置可以采用`三模冗余`也叫（3，1）重复码，`LDPC算法`
     
     `汉明纠错码`比较适用
     
     __init_safe_chunk
     
     __free_safe_chunk
     
     __chunk_write						使用这个接口写入内容，并且保存三份
     
     __chunk_read						使用这个接口读取内容
     
     [纠错码wiki](https://zh.wikipedia.org/wiki/%E7%BA%A0%E9%94%99%E7%A0%81#cite_note-3)
     
     [里德-所罗门码](https://zh.wikipedia.org/wiki/%E9%87%8C%E5%BE%B7-%E6%89%80%E7%BD%97%E9%97%A8%E7%A0%81)
     
     

### 第五题：3R的内存管理器

- 在第四题的基础上，进一步提高性能和实时性，兼顾3R (Reliable 可靠，Robust 健壮，Real-time 实时）;
- 使用benchmark进行测试，根据性能数据以及测试中占用的物理内存综合评估方案，目标平台为x86_64。



为了可靠性，我们要建立一个完整的错误报告

### 使用宏编译不同的版本

通过使用宏和条件编译指令，我们可以在同一份代码中实现不同版本的功能。这样可以使得我们可以根据不同的需求编译出不同版本的程序，从而适应不同的环境和要求。

下面是一些实现的示例：

1. 定义宏

可以使用 `#define` 指令定义一个宏，例如：

```
cCopy code
#define VERSION 1
```

这里定义了一个名为 `VERSION` 的宏，其值为 1。

1. 条件编译

可以使用 `#ifdef`、`#ifndef`、`#else` 和 `#endif` 等指令来实现条件编译。例如：

```
cCopy code
#ifdef VERSION
    // 版本 1 的代码
#else
    // 版本 2 的代码
#endif
```

在这个示例中，如果 `VERSION` 宏已经被定义，则编译器会编译版本 1 的代码；否则编译器会编译版本 2 的代码。

1. 使用命令行选项

可以使用 GCC 的命令行选项来控制编译结果。例如：

```
bashCopy code$ gcc -DVERSION=1 program.c -o program1
$ gcc -DVERSION=2 program.c -o program2
```

在这个示例中，使用 `-D` 选项定义 `VERSION` 宏的值，从而编译出不同版本的程序。

除了上述示例外，还有其他方法可以实现不同版本的功能，比如使用配置文件、使用插件等。不过无论采用何种方法，都应该尽可能地保持代码的简洁和可维护性。







```
0
1
```

